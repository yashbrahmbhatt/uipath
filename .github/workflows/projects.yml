name: Build Changed Projects

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  initialize:
    runs-on: [self-hosted, windows]
    steps:
      - uses: actions/checkout@v3

      - name: Configure Git for GitHub Actions
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
          
  detect-changes:
    needs: initialize
    runs-on: [windows, self-hosted]
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2  # Required for HEAD~1 to work

      - name: Get Changed Files
        id: get-changed-files
        shell: powershell
        run: |
          try {
            $changed = git diff --name-only $env:GITHUB_EVENT_BEFORE $env:GITHUB_SHA
            if (-not $changed) {
              $changed = git diff --name-only HEAD~1 HEAD
            }
          } catch {
            $changed = git diff --name-only HEAD~1 HEAD
          }

          $json = $changed | ConvertTo-Json -Compress
          "changed=$json" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Changed files: $json"

      - name: Map Changed Projects
        id: map-changes
        shell: powershell
        run: |
          $changedFiles = ConvertFrom-Json '${{ steps.get-changed-files.outputs.changed }}'
          $monoJson = Get-Content "mono.json" | ConvertFrom-Json

          $projectMap = @{}
          $matchedIds = @()

          foreach ($project in $monoJson.projects) {
            $projectMap[$project.id] = $project
          }

          foreach ($project in $monoJson.projects) {
            if (-not $project.build) { continue }

            $projectPath = $project.path.Replace('/', '\')
            foreach ($file in $changedFiles) {
              $filePath = $file.Replace('/', '\')
              if ($filePath -like "$projectPath*") {
                $matchedIds += $project.id
                break
              }
            }
          }

          $outMap = @{
            matchedIds = $matchedIds
            monoJson   = $monoJson | ConvertTo-Json -Depth 10 -Compress
          }

          $json = $outMap | ConvertTo-Json -Depth 10 -Compress
          "output=$json" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Matched projects: $($matchedIds -join ', ')"

      - name: Expand Transitive Dependencies
        id: expand
        shell: powershell
        run: |
          $input = ConvertFrom-Json '${{ steps.map-changes.outputs.output }}'
          $matchedIds = @{}
          foreach ($id in $input.matchedIds) {
            $matchedIds[$id] = $true
          }

          $projectMap = @{}
          foreach ($p in $input.monoJson.projects) {
            $projectMap[$p.id] = $p
          }

          function Add-DependentProjectsRecursively {
            param ($projectMap, $matchedIds)
            $added = $false
            foreach ($p in $projectMap.Values) {
              if ($matchedIds.ContainsKey($p.id)) { continue }
              if ($p.PSObject.Properties['dependsOn']) {
                foreach ($d in $p.dependsOn) {
                  if ($matchedIds.ContainsKey($d)) {
                    $matchedIds[$p.id] = $true
                    $added = $true
                    break
                  }
                }
              }
            }
            if ($added) {
              Add-DependentProjectsRecursively $projectMap $matchedIds
            }
          }

          Add-DependentProjectsRecursively $projectMap $matchedIds

          $out = @{
            matchedIds = $matchedIds.Keys
            monoJson   = $input.monoJson
          }
          $json = $out | ConvertTo-Json -Depth 10 -Compress
          "output=$json" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Expanded matched projects: $($matchedIds.Keys -join ', ')"

      - name: TopoSort & Emit Matrix
        id: set-matrix
        shell: powershell
        run: |
          Write-Host ">>> Starting TopoSort step"
                  
          # Parse the input JSON
          $input = ConvertFrom-Json '${{ steps.expand.outputs.output }}'
          Write-Host "Parsed input JSON"
          Write-Host "Matched IDs: $($input.matchedIds -join ', ')"
          Write-Host "Project count: $($input.monoJson.projects.Count)"
                  
          # Build project map
          $projectMap = @{}
          foreach ($p in $input.monoJson.projects) {
            $projectMap[$p.id] = $p
          }
          Write-Host "Constructed projectMap with keys: $($projectMap.Keys -join ', ')"
                  
          # Topological sort definition
          function TopoSort {
            param ($projectMap, $matchedIds)
            $visited = @{}
            $result = New-Object System.Collections.Generic.List[object]
            function Visit {
              param ($id)
              Write-Host "Visiting: $id"
              if ($visited[$id] -eq 'temp') { throw "Cycle at $id" }
              if ($visited[$id]) { return }
              $visited[$id] = 'temp'
              $proj = $projectMap[$id]
              if ($proj.PSObject.Properties['dependsOn']) {
                foreach ($dep in $proj.dependsOn) {
                  Write-Host "  $id depends on $dep"
                  if ($matchedIds -contains $dep) {
                    Visit $dep
                  } else {
                    Write-Host "  Skipping dependency $dep (not in matchedIds)"
                  }
                }
              }
              $visited[$id] = 'perm'
              $result.Add($proj)
            }
            foreach ($id in $input.matchedIds) {
              Visit $id
            }
            return $result
          }
                
          # Execute topological sort
          $sorted = TopoSort $projectMap $input.matchedIds
          Write-Host "Sorted projects: $($sorted | ForEach-Object { $_.id } -join ', ')"
                
          # Build matched array
          $matched = @()
          foreach ($p in $sorted) {
            $matched += [PSCustomObject]@{
              id          = $p.id
              path        = $p.path
              type        = $p.type
              deploySteps = $p.deploySteps
              dependsOn   = $p.dependsOn
            }
          }
          Write-Host "Final matched projects: $($matched | ForEach-Object { $_.id } -join ', ')"
          Write-Host "Matched count: $($matched.Count)"
                
          # Build JSON matrix
          if ($matched.Count -eq 0) {
            Write-Host "No matched projects. Empty matrix."
            $matrix = '{"include":[]}'
          } else {
            $json = $matched | ConvertTo-Json -Depth 5 -Compress
            Write-Host "Raw JSON: $json"
                
            if ($matched.Count -eq 1) {
              Write-Host "Single matched project, wrapping in array"
              $matrix = "{`"include`":[${json}]}"
            } else {
              Write-Host "Multiple matched projects"
              $matrix = "{`"include`":$json}"
            }
          }
                
          # Output matrix
          "matrix=$matrix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Final matrix: $matrix"
          Write-Host ">>> TopoSort step complete"
    
  project:
    environment: Dev
    name: Build Changed Projects
    if: ${{ needs.detect-changes.outputs.matrix != '{"include":[]}' }}
    needs: detect-changes
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    runs-on: [self-hosted, windows]
    steps:
      - uses: actions/checkout@v3
        name: "Checkout Project ${{ matrix.id }}"
        with: { fetch-depth: 0 }

      - id: compute-version
        name: "Compute Version for ${{ matrix.id }}"
        shell: powershell
        run: |
          $projectId = "${{ matrix.id }}"
          $yy = [int](Get-Date -Format "yy")
          $mm = [int](Get-Date -Format "MM")
          $base = "$yy.$mm"

          git fetch --tags

          $pattern = "$projectId@$base.*"
          $tags = git tag --list $pattern

          if (-not $tags) {
            $patch = 0
          } else {
            $patches = $tags | ForEach-Object {
              if ($_ -match "@$base\.(\d+)$") { [int]$matches[1] } else { 0 }
            }
            $patch = ($patches | Measure-Object -Maximum).Maximum + 1
          }

          $version = "$base.$patch"
          $fullVersion = "$projectId@$version"

          Write-Host "Computed version: $fullVersion"
          "VERSION=$version" >> $env:GITHUB_ENV
          "FULL_VERSION=$fullVersion" >> $env:GITHUB_ENV
          "version=$version" >> $env:GITHUB_OUTPUT
          "full_version=$fullVersion" >> $env:GITHUB_OUTPUT

      - uses: actions/checkout@v3
        with: { fetch-depth: 0 }

      - name: Restore, Build and Package VS Project
        if: ${{ startsWith(matrix.type, 'vs') }}
        shell: powershell
        id: build-vs
        run: |
          cd ${{ matrix.path }}
          $csproj = Get-ChildItem *.csproj -Recurse | Select-Object -First 1
          if ($csproj -ne $null) {
            dotnet restore $csproj.FullName
            dotnet build $csproj.FullName --configuration Release
            dotnet pack $csproj.FullName --configuration Release -p:PackageVersion=${{ steps.compute-version.outputs.version }} --output ./
          } else {
            Write-Host "No .csproj found. Skipping."
            exit 1
          }
          "nuget_path=$version" >> $env:GITHUB_OUTPUT

      - name: Restore, Build and Package Project
        if: ${{ startsWith(matrix.type, 'uipath') }}
        shell: powershell
        id: build-uipath
        run: |
          echo "Packing UiPath project ${{ matrix.id }}"
          cd ${{ matrix.path }}
          uipcli pack --project-path .
     
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.compute-version.outputs.full_version }}
          path: ${{ matrix.path }}/*.nupkg
        id: upload-artifact
      
      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.github_token }}
        with:
          tag_name: ${{ steps.compute-version.outputs.full_version }}
          release_name: Release ${{ steps.compute-version.outputs.full_version }}
          draft: false
          prerelease: false
      
      - name: Publish NuGet Package to GitHub Packages
        shell: powershell
        run: |
          $packagePath = "${{ matrix.path }}/${{ matrix.id }}.${{ steps.compute-version.outputs.version }}.nupkg"
          Write-Host "Pushing package to GitHub Packages: $packagePath"

          dotnet nuget push @(
              "$packagePath",
              "--api-key", "${{ secrets.GITHUB_TOKEN }}",
              "--source", "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json",
              "--skip-duplicate"
          )
    
      - name: Publish NuGet Package to nuget.org
        shell: powershell
        run: |
          $packagePath = "${{ matrix.path }}/${{ matrix.id }}.${{ steps.compute-version.outputs.version }}.nupkg"
          Write-Host "Pushing package to nuget.org: $packagePath"
          $apiKey = "${{ secrets.NUGET_ORG_API_KEY }}"
          if (-not $apiKey) {
            Write-Error "NUGET_ORG_API_KEY is not set. Skipping nuget.org push."
            exit 1
          }
          dotnet nuget push @(
            "$packagePath",
            "--api-key", "${{ secrets.NUGET_ORG_API_KEY }}",
            "--source", "https://api.nuget.org/v3/index.json",
            "--skip-duplicate"
          )
