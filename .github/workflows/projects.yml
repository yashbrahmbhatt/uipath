name: Build Changed Projects

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  initialize:
    runs-on: [self-hosted, windows]
    steps:
      - uses: actions/checkout@v3

      - name: Configure Git for GitHub Actions
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
          
  detect-changes:
    runs-on: [windows, self-hosted]
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2  # Required for HEAD~1 to work

      - name: Download jq
        run: |
          Invoke-WebRequest -Uri https://github.com/stedolan/jq/releases/download/jq-1.6/jq-win64.exe -OutFile jq.exe
        shell: powershell

      - name: Add jq to PATH
        run: |
          $env:PATH = "$PWD;$env:PATH"
          jq.exe --version
        shell: powershell

      - name: Detect Changed Projects
        id: set-matrix
        shell: powershell
        run: |
          Write-Host "Detecting changes..."
          try {
            $changedFiles = git diff --name-only $env:GITHUB_EVENT_BEFORE $env:GITHUB_SHA
            if (-not $changedFiles) {
              $changedFiles = git diff --name-only HEAD~1 HEAD
            }
          } catch {
            $changedFiles = git diff --name-only HEAD~1 HEAD
          }

          Write-Host "Changed files:"
          $changedFiles

          $monoJson = Get-Content "mono.json" | ConvertFrom-Json
          $projectMap = @{}
          $matchedIds = @{}

          # Map all projects by ID
          foreach ($project in $monoJson.projects) {
            $projectMap[$project.id] = $project
          }

          # First pass: mark directly changed projects
          foreach ($project in $monoJson.projects) {
            if (-not $project.build) { continue }

            $projectPath = $project.path.Replace('/', '\')
            foreach ($file in $changedFiles) {
              $filePath = $file.Replace('/', '\')
              if ($filePath -like "$projectPath*") {
                $matchedIds[$project.id] = $true
                break
              }
            }
          }

          # Recursive dependency expander
          function Add-DependentProjectsRecursively {
            param (
              [hashtable]$projectMap,
              [hashtable]$matchedIds
            )

            $dependentsAdded = $false

            foreach ($project in $projectMap.Values) {
              if ($matchedIds.ContainsKey($project.id)) { continue }

              if ($project.PSObject.Properties['dependsOn']) {
                foreach ($depId in $project.dependsOn) {
                  if ($matchedIds.ContainsKey($depId)) {
                    $matchedIds[$project.id] = $true
                    $dependentsAdded = $true
                    break
                  }
                }
              }
            }

            if ($dependentsAdded) {
              Add-DependentProjectsRecursively -projectMap $projectMap -matchedIds $matchedIds
            }
          }

          # Expand all transitive dependents
          Add-DependentProjectsRecursively -projectMap $projectMap -matchedIds $matchedIds
          
          # Topological sort helper
          function TopoSort {
            param (
              [hashtable]$projectMap,
              [hashtable]$matchedIds
            )

            $visited = @{}
            $result = New-Object System.Collections.Generic.List[object]

            function Visit {
              param ($id)
              if ($visited[$id] -eq 'temp') {
                throw "Cyclic dependency detected at $id"
              }
              if ($visited[$id]) { return }
            
              $visited[$id] = 'temp'
              $proj = $projectMap[$id]
              if ($proj.PSObject.Properties['dependsOn']) {
                foreach ($depId in $proj.dependsOn) {
                  if ($matchedIds.ContainsKey($depId)) {
                    Visit $depId
                  }
                }
              }
              $visited[$id] = 'perm'
              $result.Add($proj)
            }
          
            foreach ($id in $matchedIds.Keys) {
              Visit $id
            }
          
            return $result
          }

          # Run topological sort
          $sortedProjects = TopoSort -projectMap $projectMap -matchedIds $matchedIds

          # Prepare matrix
          $matched = @()
          foreach ($project in $sortedProjects) {
            $matched += [PSCustomObject]@{
              id          = $project.id
              path        = $project.path
              type        = $project.type
              deploySteps = $project.deploySteps
            }
          }

          
          Write-Host "Detected matrix: $matrix"
          "matrix=$matrix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
    
  project:
    environment: Dev
    name: Build Changed Projects
    if: ${{ needs.detect-changes.outputs.matrix != '{"include":[]}' }}
    needs: detect-changes
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    runs-on: [self-hosted, windows]
    steps:
      - uses: actions/checkout@v3
        name: "Checkout Project ${{ matrix.id }}"
        with: { fetch-depth: 0 }

      - id: compute-version
        name: "Compute Version for ${{ matrix.id }}"
        shell: powershell
        run: |
          $projectId = "${{ matrix.id }}"
          $yy = [int](Get-Date -Format "yy")
          $mm = [int](Get-Date -Format "MM")
          $base = "$yy.$mm"

          git fetch --tags

          $pattern = "$projectId@$base.*"
          $tags = git tag --list $pattern

          if (-not $tags) {
            $patch = 0
          } else {
            $patches = $tags | ForEach-Object {
              if ($_ -match "@$base\.(\d+)$") { [int]$matches[1] } else { 0 }
            }
            $patch = ($patches | Measure-Object -Maximum).Maximum + 1
          }

          $version = "$base.$patch"
          $fullVersion = "$projectId@$version"

          Write-Host "Computed version: $fullVersion"
          "VERSION=$version" >> $env:GITHUB_ENV
          "FULL_VERSION=$fullVersion" >> $env:GITHUB_ENV
          "version=$version" >> $env:GITHUB_OUTPUT
          "full_version=$fullVersion" >> $env:GITHUB_OUTPUT

      - uses: actions/checkout@v3
        with: { fetch-depth: 0 }

      - name: Restore, Build and Package VS Project
        if: ${{ startsWith(matrix.type, 'vs') }}
        shell: powershell
        id: build-vs
        run: |
          cd ${{ matrix.path }}
          $csproj = Get-ChildItem *.csproj -Recurse | Select-Object -First 1
          if ($csproj -ne $null) {
            dotnet restore $csproj.FullName
            dotnet build $csproj.FullName --configuration Release
            dotnet pack $csproj.FullName --configuration Release -p:PackageVersion=${{ steps.compute-version.outputs.version }} --output ./
          } else {
            Write-Host "No .csproj found. Skipping."
            exit 1
          }
          "nuget_path=$version" >> $env:GITHUB_OUTPUT

      - name: Restore, Build and Package Project
        if: ${{ startsWith(matrix.type, 'uipath') }}
        shell: powershell
        id: build-uipath
        run: |
          echo "Packing UiPath project ${{ matrix.id }}"
          cd ${{ matrix.path }}
          uipcli pack --project-path .
     
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.compute-version.outputs.full_version }}
          path: ${{ matrix.path }}/*.nupkg
        id: upload-artifact
      
      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.github_token }}
        with:
          tag_name: ${{ steps.compute-version.outputs.full_version }}
          release_name: Release ${{ steps.compute-version.outputs.full_version }}
          draft: false
          prerelease: false
      
      - name: Publish NuGet Package to GitHub Packages
        shell: powershell
        run: |
          $packagePath = "${{ matrix.path }}/${{ matrix.id }}.${{ steps.compute-version.outputs.version }}.nupkg"
          Write-Host "Pushing package to GitHub Packages: $packagePath"

          dotnet nuget push @(
              "$packagePath",
              "--api-key", "${{ secrets.GITHUB_TOKEN }}",
              "--source", "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json",
              "--skip-duplicate"
          )
    
      - name: Publish NuGet Package to nuget.org
        shell: powershell
        run: |
          $packagePath = "${{ matrix.path }}/${{ matrix.id }}.${{ steps.compute-version.outputs.version }}.nupkg"
          Write-Host "Pushing package to nuget.org: $packagePath"
          $apiKey = "${{ secrets.NUGET_ORG_API_KEY }}"
          if (-not $apiKey) {
            Write-Error "NUGET_ORG_API_KEY is not set. Skipping nuget.org push."
            exit 1
          }
          dotnet nuget push @(
            "$packagePath",
            "--api-key", "${{ secrets.NUGET_ORG_API_KEY }}",
            "--source", "https://api.nuget.org/v3/index.json",
            "--skip-duplicate"
          )
