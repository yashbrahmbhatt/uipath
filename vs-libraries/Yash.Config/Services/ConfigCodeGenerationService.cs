using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Yash.Config.ConfigurationFile;
using Yash.Config.Models;
using Yash.Utility.Services.CodeGeneration;
using Yash.Utility.Services.CodeGeneration.Models;

namespace Yash.Config.Services
{
    /// <summary>
    /// Specialized code generation service for generating configuration classes from ConfigFile models
    /// </summary>
    public class ConfigCodeGenerationService : BaseCodeGenerationService
    {
        private readonly Action<string, TraceEventType>? _logger;

        public ConfigCodeGenerationService(Action<string, TraceEventType>? logger = null)
        {
            _logger = logger;
        }

        /// <summary>
        /// Generates a complete configuration class file from a ConfigFile model
        /// </summary>
        /// <param name="configFile">The configuration file model</param>
        /// <param name="className">Name of the generated class</param>
        /// <param name="namespaceName">Namespace for the generated class</param>
        /// <param name="additionalUsings">Additional using statements (comma-separated)</param>
        /// <returns>Generated C# code as string</returns>
        public string GenerateConfigurationClass(
            ConfigFile configFile,
            string className,
            string namespaceName,
            string additionalUsings = "")
        {
            _logger?.Invoke($"[ConfigCodeGeneration] Generating class '{className}' in namespace '{namespaceName}'", TraceEventType.Information);

            var file = CreateCodeGenerationFile(configFile, className, namespaceName, additionalUsings);
            return GenerateFile(file);
        }

        /// <summary>
        /// Creates a CodeGenerationFile model from a ConfigFile
        /// </summary>
        private CodeGenerationFile CreateCodeGenerationFile(
            ConfigFile configFile,
            string className,
            string namespaceName,
            string additionalUsings)
        {
            var file = new CodeGenerationFile
            {
                HeaderComments = new List<string>
                {
                    "------------------------------------------------------------------------------",
                    "<auto-generated>",
                    $"    This code was generated by the Yash.Config GenerateConfigClass wizard on {DateTime.Now:dd-MM-yyyy HH:mm:ss}.",
                    "",
                    "    Changes to this file may be overwritten if the tool is rerun.",
                    "</auto-generated>",
                    "------------------------------------------------------------------------------"
                },
                Usings = CreateUsings(configFile, additionalUsings),
                Namespace = new CodeGenerationNamespace
                {
                    Name = namespaceName,
                    Classes = new List<CodeGenerationClass> { CreateConfigurationClass(configFile, className) }
                }
            };
            return file;
        }

        /// <summary>
        /// Creates the using statements for the generated file
        /// </summary>
        private List<CodeGenerationUsing> CreateUsings(ConfigFile configFile, string additionalUsings)
        {
            var usings = new List<CodeGenerationUsing>
            {
                new() { Namespace = "System" },
                new() { Namespace = "Yash.Configuration.Models.Configuration" }
            };

            // Analyze config file to determine required usings
            var usedTypes = new HashSet<string>();
            
            foreach (var setting in configFile.Settings)
                usedTypes.Add(setting.Type);
            foreach (var asset in configFile.Assets)
                usedTypes.Add(asset.Type);
            foreach (var file in configFile.Files)
                usedTypes.Add(file.Type);

            if (usedTypes.Any(t => t.StartsWith("List<")))
                usings.Add(new CodeGenerationUsing { Namespace = "System.Collections.Generic" });
            
            if (usedTypes.Any(t => t.Contains("DataTable")))
                usings.Add(new CodeGenerationUsing { Namespace = "System.Data" });

            // Add additional usings
            if (!string.IsNullOrEmpty(additionalUsings))
            {
                var additionalNamespaces = additionalUsings.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
                foreach (var ns in additionalNamespaces)
                {
                    usings.Add(new CodeGenerationUsing { Namespace = ns });
                }
            }

            return usings;
        }

        /// <summary>
        /// Creates the configuration class model
        /// </summary>
        private CodeGenerationClass CreateConfigurationClass(ConfigFile configFile, string className)
        {
            var configClass = new CodeGenerationClass
            {
                Name = className,
                AccessModifier = "public",
                BaseClass = "Yash.Configuration.Models.Configuration.Configuration",
                Properties = new List<CodeGenerationProperty>()
            };

            // Add settings properties
            if (configFile.Settings.Any())
            {
                configClass.Properties.AddRange(
                    configFile.Settings.Select(setting => CreateProperty(setting.Type, setting.Name, setting.Description))
                );
            }

            // Add assets properties
            if (configFile.Assets.Any())
            {
                configClass.Properties.AddRange(
                    configFile.Assets.Select(asset => CreateProperty(asset.Type, asset.Name, asset.Description))
                );
            }

            // Add files properties
            if (configFile.Files.Any())
            {
                configClass.Properties.AddRange(
                    configFile.Files.Select(file => CreateProperty(file.Type, file.Name, file.Description))
                );
            }

            return configClass;
        }

        /// <summary>
        /// Creates a property model from configuration item details
        /// </summary>
        private CodeGenerationProperty CreateProperty(string typeName, string name, string description)
        {
            var sanitizedName = SanitizeName(name);
            
            return new CodeGenerationProperty
            {
                Name = sanitizedName,
                Type = string.IsNullOrWhiteSpace(typeName) ? "string" : typeName,
                AccessModifier = "public",
                HasGetter = true,
                HasSetter = true,
                Documentation = !string.IsNullOrWhiteSpace(description) ? EscapeXml(description) : null
            };
        }

        /// <summary>
        /// Sanitizes a name to be a valid C# identifier
        /// </summary>
        private static string SanitizeName(string rawName)
        {
            if (string.IsNullOrWhiteSpace(rawName))
                return "Unnamed";

            // Filter to keep only letters, digits, and underscores (ASCII only for now)
            var validChars = new string(rawName.Where(c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_').ToArray());

            if (string.IsNullOrEmpty(validChars))
                return "Unnamed";

            if (char.IsDigit(validChars.FirstOrDefault()))
                validChars = "_" + validChars;

            return validChars;
        }

        /// <summary>
        /// Escapes XML special characters for documentation
        /// </summary>
        private static string EscapeXml(string input)
        {
            if (input == null)
                return "";

            return input
                .Replace("&", "&amp;")
                .Replace("<", "&lt;")
                .Replace(">", "&gt;")
                .Replace("\"", "&quot;")
                .Replace("'", "&apos;");
        }
    }
}